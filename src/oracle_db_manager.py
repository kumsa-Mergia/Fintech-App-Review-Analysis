import os
import cx_Oracle
import pandas as pd # Make sure pandas is imported if you're using fetch_dataframe

class OracleDBManager:
    def __init__(self, user, password, dsn, mode=None):
        self.user = user
        self.password = password
        self.dsn = dsn
        # For typical application users, you usually don't need a specific mode.
        # If this caused ORA-01017 before, ensure it's None for FINTECH_APP_USER.
        self.mode = mode
        self.connection = None
        self.cursor = None

    def connect(self):
        try:
            print(f"Attempting to connect to DSN: {self.dsn} as user: {self.user}" + (f" with mode: {self.mode}" if self.mode else ""))

            connect_args = {
                "user": self.user,
                "password": self.password,
                "dsn": self.dsn
            }
            if self.mode is not None:
                connect_args["mode"] = self.mode

            self.connection = cx_Oracle.connect(**connect_args)
            self.cursor = self.connection.cursor()
            print("Database connection established.")
        except cx_Oracle.Error as e:
            error_obj = e.args[0]
            raise Exception(f"Connection error: {error_obj.message}")

    def close(self):
        if self.cursor:
            self.cursor.close()
            print("Cursor closed.")
        if self.connection:
            self.connection.close()
            print("Database connection closed.")

    # --- Table Creation Method ---
    def create_tables(self):
        if not self.connection:
            self.connect() # Ensure connection is open

        try:
            # --- Check and Create 'banks' table ---
            self.cursor.execute("SELECT table_name FROM user_tables WHERE table_name = 'BANKS'")
            banks_table_exists = self.cursor.fetchone()

            if banks_table_exists:
                print("Banks table already exists, skipping creation.")
            else:
                print("Creating banks table...")
                self.cursor.execute("""
                    CREATE TABLE banks (
                        id    NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY, -- Primary Key, auto-incrementing
                        name  VARCHAR2(255) UNIQUE NOT NULL, -- Bank name, ensure uniqueness
                        CONSTRAINT pk_banks PRIMARY KEY (id)
                    )
                """)
                self.connection.commit()
                print("Banks table created successfully.")

            # --- Check and Create 'reviews' table ---
            self.cursor.execute("SELECT table_name FROM user_tables WHERE table_name = 'REVIEWS'")
            reviews_table_exists = self.cursor.fetchone()

            if reviews_table_exists:
                print("Reviews table already exists, skipping creation.")
            else:
                print("Creating reviews table...")
                self.cursor.execute("""
                    CREATE TABLE reviews (
                        review_id     NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY, -- Primary Key, auto-incrementing
                        bank_id       NUMBER NOT NULL,
                        rating        NUMBER(1,0), -- Assuming rating is a single digit (e.g., 1-5)
                        review_text   VARCHAR2(4000), -- Adjust size; use CLOB for very long text
                        review_date   DATE,           -- For dates (YYYY-MM-DD)
                        source        VARCHAR2(100),
                        CONSTRAINT pk_reviews PRIMARY KEY (review_id),
                        CONSTRAINT fk_bank_id FOREIGN KEY (bank_id) REFERENCES banks(id) -- Added FK to banks.id
                    )
                """)
                self.connection.commit()
                print("Reviews table created successfully.")

        except Exception as e:
            self.connection.rollback() # Rollback on error
            print(f"⚠️ Error during table creation: {e}")
            raise # Re-raise if you want the error to propagate

    # --- Insert Banks Method ---
    def insert_banks(self, bank_names):
        if not self.connection:
            raise Exception("Not connected to the database. Call .connect() first.")
        bank_id_map = {}
        for name in bank_names:
            try:
                bank_id_var = self.cursor.var(cx_Oracle.NUMBER)
                self.cursor.execute(
                    "INSERT INTO banks (name) VALUES (:1) RETURNING id INTO :2",
                    [name, bank_id_var]
                )
                bank_id_map[name] = int(bank_id_var.getvalue()[0])
            except cx_Oracle.IntegrityError:
                self.connection.rollback() # Rollback the failed insert
                # If it's an IntegrityError (e.g., unique constraint violation for name),
                # it means the bank already exists. Fetch its ID.
                self.cursor.execute("SELECT id FROM banks WHERE name = :1", [name])
                result = self.cursor.fetchone()
                if result:
                    bank_id_map[name] = result[0]
                else:
                    # This case should ideally not happen if IntegrityError implies name exists
                    raise Exception(f"Failed to find existing bank '{name}' after integrity error.")
            except cx_Oracle.Error as e:
                # Catch other potential database errors during insert
                self.connection.rollback()
                error_obj = e.args[0]
                raise Exception(f"Error inserting bank '{name}': {error_obj.message}")

        self.connection.commit() # Commit all successful bank inserts at once
        print(f"Inserted/updated {len(bank_id_map)} banks.")
        return bank_id_map

    # --- Insert Reviews Method ---         
    def insert_reviews(self, df, bank_id_map):
        if not self.connection:
            raise Exception("Not connected to the database. Call .connect() first.")
        data_to_insert = []
        for _, row in df.iterrows():
            bank_id = bank_id_map.get(row['bank'])
            if bank_id is None:
                print(f"Warning: Bank '{row['bank']}' not found in bank_id_map. Skipping review.")
                continue

            # Ensure date is handled correctly.
            # Convert to string to ensure TO_DATE receives a string, even if pandas read_csv sometimes
            # infers it as datetime.object (which is string in this case).
            review_date_str = str(row['date']) 

            data_to_insert.append((
                bank_id,
                row['rating'],
                row['review'], # Assuming this is 'review_text' content in your CSV
                review_date_str, # Use the string representation for TO_DATE
                row['source']
            ))

        if data_to_insert:
            try:
                self.cursor.executemany("""
                    INSERT INTO reviews (bank_id, rating, review_text, review_date, source)
                    VALUES (:1, :2, :3, TO_DATE(:4, 'MM/DD/YYYY'), :5) -- <-- CHANGE THIS LINE!
                """, data_to_insert)
                self.connection.commit()
                print(f"Inserted {len(data_to_insert)} reviews.")
            except cx_Oracle.Error as e:
                self.connection.rollback()
                error_obj = e.args[0]
                raise Exception(f"Error inserting reviews: {error_obj.message}")
        else:
            print("No reviews to insert.")                           
